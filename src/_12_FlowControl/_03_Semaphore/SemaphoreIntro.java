package _12_FlowControl._03_Semaphore;

/*
 * Semaphore(信号量):
 * 不仅是在Java中有信号量, 操作系统中也有; 它的作用是用来限制或管理数量有限的资源的使用情况;
 * 类比到现实场景中, 例如工厂不能开太多, 因为有污染, 但是也不能没有工厂, 因为要发展, 所以启用排污许可证, 最多只能发3张;
 * 信号量的作用是维护一个"许可证"的计数, 线程可以"获取"一个"许可证", 每当一个线程"获取"一张"许可证",
 * 信号量维护的剩余"许可证"数量就减一; 线程也可以"归还"一个"许可证", 每当一个线程"归还"一张"许可证",
 * 信号量维护的剩余"许可证"数量就加一; 当信号量维护的"许可证"数量为0, 那么下一个想要获取"许可证"的线程就必须等待(阻塞),
 * 直到有另外的线程归还了"许可证";
 * Semaphore和Lock(的实现类)很像, 区别在于, Lock一次只允许一个线程进入临界区, 而Semaphore一次允许多个线程进入临界区;
 *
 * Semaphore使用流程:
 * 1. 初始化Semaphore并指定许可证的数量;
 * 2. 执行任务前, 线程调用acquire()或者acquireUniterruptibly()方法获取许可证;
 * 3. 在任务执行结束后, 调用release()来释放许可证;
 *
 * Semaphore主要方法:
 * 1. Semaphore(int permits, boolean fair):
 *    构造方法, 可以设置是否要使用公平策略(fair参数); 在公平的情况下, 所有等待线程会在一个FIFO的等待队列中,
 *    许可证会发放给等待了最长时间的线程;
 * 2. acquire()和acquireUniterruptibly():
 *    获取许可证的方法; 区别在于, acquire()能够响应中断, 而acquireUniterruptibly()不能响应中断;
 *    (acquire()方法类似于Lock中的lockInterruptibly()方法, acquireUniterruptibly()类似于Lock中的lock()方法)
 * 3. tryAcquire()/tryAcquire(int timeout):
 *    会返回一个boolean值, 尝试获得许可证, 如果获得失败, 就立即返回, 不会陷入阻塞;
 *    可以传入超时参数, 意为, 在"timeout"时间内不停地去尝试获得许可证, 获得了就返回, 超时了也返回;
 *    (类似于Lock的tryLock());
 * 4. release():
 *    归还许可证的方法; 必须手动调用此方法来归还许可证, 许可证不会自动归还;
 *    (类似于Lock的unlock())
 *
 * Semaphore的特殊用法:
 * 获取许可证的方法可以传入参数, permits, 意为一次获取多个许可证, 例如可以使用acquire(3), 一次获取3个许可证;
 * 若一次获取了多个许可证, 那么在release()的时候, 需要释放同样数量的许可证;
 * 适用场景例如, 某一个方法需要消耗比其他方法多很多的资源, 那么我们就让他一次多获取几个许可证;
 * 以这种方式, 我们可以更合理地使用资源;
 *
 * Semaphore的注意点:
 * 1. 获取和释放的许可证的数量必须一致, 否则随着时间的推移, 许可证的数量可能会不够用, 会导致线程永久阻塞,
 *    程序卡死;
 * 2. 注意在初始化Semaphore的时候设置公平性, 一般设置为true会更合理;
 * 3. 许可证的释放和获取对线程是没有要求的, 并不是必须由获取许可证的线程释放那个许可证;
 *    例如, 线程A获取了许可证, 然后由线程B释放, 只要逻辑合理即可;
 * 4. Semaphore的作用, 除了控制临界区最多同时有N个线程访问外, 另一个作用是可以实现"条件等待";
 *    例如, 线程1需要在线程2完成准备工作后才能开始工作, 我们就可以使用一个数量为1的Semaphore,
 *    线程2先去acquire(), 然后线程1进行acquire(), 由于此时唯一的许可证被线程2获取了,
 *    所以线程1会进入等待状态, 而线程2在完成任务后release(), 线程1才能获得许可证并继续执行,
 *    这样的话, 相当于是轻量级的CountDownLatch;
 *
 * 示例详见SemaphoreDemo.java
 */

public class SemaphoreIntro {
    public static void main(String[] args) {
    }
}
