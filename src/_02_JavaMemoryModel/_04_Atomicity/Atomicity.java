package _02_JavaMemoryModel._04_Atomicity;

/*
 * 参考: https://www.infoq.cn/article/java-memory-model-3/
 *
 * 什么是原子性:
 * 原子性是指, 对于一系列的操作, 要么全部执行成功, 要么全部不执行, 不会出现执行一半的情况;
 *
 * Java中原生的原子操作:
 * 1. 除long和double之外的基本数据类型(int, byte, boolean, short, char, float)的读取和写入(赋值)操作;
 * 2. 所有引用类型(reference)的读取和写入(赋值)操作, 不管是32位机器还是64位机器;
 * 3. java.util.concurrent.atomic.*包中所有类的原子操作;
 *
 * JMM并不保证对64位的long型和double型变量的读/写操作具有原子性:
 * 在计算机中, 数据通过总线在处理器和内存之间传递; 每次处理器和内存之间的数据传递都是通过一系列步骤来完成的,
 * 这一系列步骤称之为总线事务(bus transaction); 总线事务包括读事务(read transaction)和写事务(write transaction);
 * 读事务从内存传送数据到处理器, 写事务从处理器传送数据到内存, 每个事务会读/写内存中一个或多个物理上连续的字;
 * 这里的关键是, 总线会同步试图并发使用总线的事务, 在一个处理器执行总线事务期间, 总线会禁止其它所有的处理器和I/O设备执行内存的读/写;
 * 假设处理器A, B和C同时向总线发起总线事务, 这时总线仲裁(bus arbitration)会对竞争作出裁决,
 * 这里我们假设总线在仲裁后判定处理器A在竞争中获胜(总线仲裁会确保所有处理器都能公平的访问内存);
 * 此时处理器A继续它的总线事务, 而其它两个处理器则要等待处理器A的总线事务完成后才能开始再次执行内存访问;
 * 假设在处理器A执行总线事务期间(不管这个总线事务是读事务还是写事务), 处理器D向总线发起了总线事务, 此时处理器D的这个请求会被总线禁止;
 * 总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行, 即在任意时间点, 最多只能有一个处理器能访问内存;
 * 这个特性确保了单个总线事务之中的内存读/写操作具有原子性;
 * 在一些32位的处理器上, 如果要求对64位数据的读/写操作具有原子性, 会有比较大的开销; 为了照顾这种处理器,
 * java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的读/写具有原子性; 当JVM在这种处理器上运行时,
 * 会把一个64位long/double型变量的读/写操作拆分为两个32位的读/写操作来执行,
 * 这两个32位的读/写操作可能会被分配到不同的总线事务中执行, 此时对这个64位变量的读/写将不具有原子性;
 * 例如, 假设处理器A写一个long型变量, 同时处理器B要读这个long型变量; 处理器A中64位的写操作被拆分为两个32位的写操作,
 * 且这两个32位的写操作被分配到不同的写事务中执行; 同时处理器B中64位的读操作被拆分为两个32位的读操作,
 * 且这两个32位的读操作被分配到同一个的读事务中执行; 当处理器A先执行, 当它执行到一半时(即当处理器A执行完第一个32位的写事务时),
 * CPU时钟切换到处理器B, 处理器B执行它的读事务(包含两个32位的读操作), 那么, 处理器B将看到的是仅仅被处理器A"写了一半"的无效值;
 * 但在实际开发中, 我们使用的商用Java虚拟机中已经保证了64位的long/double型变量的读/写具有原子性, 所以不用过于担心;
 *
 * 原子操作 + 原子操作 != 原子操作
 * 简单地把原子操作组合在一起, 并不能保证整体依然具有原子性;
 */

public class Atomicity {
    public static void main(String[] args) {
    }
}
