package _02_JavaMemoryModel._03_FieldVisibility;

/*
 * 参考: https://www.jianshu.com/p/e0e80d004a86
 *      https://www.jianshu.com/p/8a58d8335270
 *      https://www.jianshu.com/p/b9186dbebe8e
 *      https://www.infoq.cn/article/java-memory-model-1/
 *      https://www.infoq.cn/article/java-memory-model-2/
 *      https://www.infoq.cn/article/java-memory-model-3/
 *
 * 什么不是happens-before:
 * 两个线程没有相互配合的机制, 所以代码X和Y的执行结果并不能保证总被对方看到, 这就不具备happens-before;
 *
 * 什么是happens-before:
 * 对于我们程序员来说, happens-before是一个语义, 它是为了方便程序员在阅读源码时或者编写多线程程序时理解内存可见性的概念而设计的,
 * 它的具体语义为:
 * 1. 如果一个操作happens-before于另一个操作, 那么我们说第一个操作的执行结果对于第二个操作是可见的,
 *    而且第一个操作的执行顺序排在第二个操作之前; (对于程序猿来说)
 * 2. 两个操作之间存在happens-before关系, 并不意味着CPU真正执行时必须要按照happens-before关系指定的顺序来执行,
 *    如果重排序之后的执行结果与按happens-before关系来执行的结果一致, 那么这种重排序是允许的; (对编译器和处理器来说)
 * happens-before有很多具体的规则, 这些规则都套用了上面的语义(也就是用上面的语义来解释这些规则的意思), 详见下面具体规则的描述;
 * JMM在底层为我们程序员做了很多工作来保证内存的数据可见性、正确同步的代码的顺序一致性、原子性等, 可以说,
 * happens-before的那些规则的描述是JMM向程序员提供的对于它在底层做的这些工作的成果的精简描述,
 * 我们只要按照happens-before的那些规则来编写多线程程序, 就能够保证数据可见性;
 *
 * 详细地解释happens-before原则:
 * 要深入地理解happens-before原则, 需要先了解数据依赖性以及as-if-serial语义;
 * 数据依赖性是指, 如果两个操作访问同一个变量, 且这两个操作中至少有一个为写操作, 那么这两个操作之间就存在数据依赖性;
 * 具体来说, 数据依赖性有以下3种类型:
 * 1). 写后读, 例如a = 1; b = a;
 * 2). 写后写, 例如a = 1; a = 2;
 * 3). 读后写, 例如a = b; b = 1;
 * 对于以上3种情况(即对于有数据依赖性的两条语句), 如果对他们进行重排序, 那么执行结果就会改变;
 * 我们知道, 编译器和CPU可能会对指令序列做重排序, 但编译器和CPU在做重排序时, 会遵守数据依赖性,
 * 即编译器和CPU不会改变存在数据依赖关系的两个操作的执行顺序;
 * 注意, 这里所说的数据依赖性仅针对单个CPU中执行的指令序列和单个线程中执行的操作, 不同CPU之间和不同线程之间的数据依赖性不被编译器和CPU考虑;
 * 说完数据依赖性, 再看一下as-if-serial语义, as-if-serial语义是指, 不管怎么重排序, 单线程程序的执行结果不能被改变;
 * 编译器、runtime和CPU都必须遵守as-if-serial语义; 为了遵守as-if-serial语义, 编译器和CPU不会对存在数据依赖关系的操作做重排序;
 * 但是, 如果操作之间不存在数据依赖关系, 这些操作是可能被编译器和CPU做重排序的; 为了具体说明, 请看下面计算圆面积的代码示例:
 *     double pi = 3.14;          // A
 *     double r = 1.0;            // B
 *     double area = pi * r * r;  // C
 * 如代码所示, A与C之间存在数据依赖关系, 同时B与C之间存在数据依赖关系; 因此, 在最终执行的指令序列中, C不能被重排序到A或B前面,
 * 因为如果C排到A或B前面, 程序的执行结果会被改变; 但A和B之间不存在数据依赖关系, 所以编译器和CPU可以重排序A和B的执行顺序;
 * as-if-serial语义把单线程程序保护了起来, 遵守as-if-serial语义的编译器、runtime和CPU共同为编写单线程程序的程序员构造了一个幻觉:
 * 单线程程序是按照程序代码编写的顺序来执行的; as-if-serial语义使单线程程序员无需担心重排序会干扰执行结果, 也无需担心内存可见性问题;
 * 那么对于多线程程序, 是怎么保证执行结果的正确、又是怎么保证数据可见性的呢? 在多线程运行的环境下, 即使遵循as-if-serial语义,
 * 程序依然可能执行出错误的结果; 为了更好地说明, 请看下面的代码例子:
 *     class Example {
 *         int a = 0;
 *         boolean flag = false;
 *
 *         public void write() {
 *             a = 1;                // 1
 *             flag = true;          // 2
 *         }
 *
 *         public void read() {
 *             if (flag) {           // 3
 *                 int res = a * a;  // 4
 *             }
 *         }
 *     }
 * 其中, flag变量是个标记, 用来标识变量a是否已被写入; 这里假设有两个线程A和B, A首先执行write()方法, 随后B执行read()方法;
 * 那么线程B在执行操作4时, 能否看到线程A在操作1对共享变量a的写入? 答案是不一定能看到; 由于操作1和操作2不存在数据依赖关系,
 * 编译器和CPU可以对这两个操作重排序, 同样, 操作3和操作4也不存在数据依赖关系, 编译器和CPU也可以对他们进行重排序, 这并不违反as-if-serial语义;
 * 让我们先来看看操作1和操作2重排序时, 会运行出什么结果: 当线程A执行write()方法时, 由于操作1和操作2被重排序,
 * 所以线程A先执行操作2, 即把flag设置为true; 假设这时CPU时钟切换到线程B, 线程B开始执行, 由于flag此时为true,
 * 所以线程B进入if语句执行计算, 但此时a还没有被线程A修改过, 所以执行结果为res = 0 * 0 = 0; 此时再切换回线程A,
 * 线程A把a赋值为1, 但线程A对a的写入并没有被B看到; 在我们的设想中, 由于线程A先执行, 线程A会先对共享变量a进行写入,
 * 所以按理来说线程B执行时应该能够看到共享变量a被写入了; 但实际情况可能并不是这样, 即这里多线程程序的语义被重排序破坏了;
 * 我们再来看一下当操作3和操作4重排序时, 会有什么样的效果: 在程序中, 操作3和操作4存在控制依赖关系, 当代码中存在控制依赖性时,
 * 编译器和CPU可能会采用猜测(Speculation)执行来克服控制相关性对并行度的影响; 以CPU的猜测执行为例,
 * 执行线程B的处理器可以提前读取并计算a * a的值, 然后把计算结果临时保存到一个名为重排序缓冲(Reorder Buffer, ROB)的硬件缓存中,
 * 当接下来操作3的条件判断为真时, 就把该计算结果写入变量res; 用伪代码的形式模拟操作3和操作4的重排序情况为:
 *     int temp = a * a;  // 4
 *     if (flag) {        // 3
 *         int res = temp;
 *     }
 * 在这种操作3和操作4被重排序的情况中, 依然是线程A先执行, 但是线程B会先对a * a进行计算, 所以整个的执行流程为:
 * 线程B先计算 a * a = 0 * 0 = 0, CPU时钟切换到线程A, 线程A把a赋值为1然后把flag赋值为true, CPU时钟再切换回线程B,
 * 此时由于flag为true, 所以进入if语句然后执行res = temp = 0; 所以最终计算结果依然是不正确的, 即这里的多线程程序的语义也被重排序破坏了;
 * 通过以上例子的分析, 我们知道, 在多线程程序的环境下, 仅仅依靠as-if-serial语义是无法保证数据可见性和最终结果的正确性的,
 * 所以我们要借助诸如synchronized关键字去给线程做同步、或者volatile关键字去保证共享变量的可见性;
 * 但是synchronized、volatile或者Lock又是怎么保证多线程程序的数据可见性和结果的正确性呢? 这其实就是JMM在底层为我们做的事情,
 * JMM通过在底层做一些特殊处理, 例如:
 * 1). 对于编译器重排序, JMM的编译器重排序规则会禁止特定类型的编译器重排序(不是所有的编译器重排序都要禁止);
 * 2). 对于处理器重排序, JMM的处理器重排序规则会要求Java编译器在生成指令序列时, 插入特定类型的内存屏障(Memory Barriers)指令,
 *     通过内存屏障指令来禁止特定类型的处理器重排序(不是所有的处理器重排序都要禁止);
 * 3). JMM会强制某线程的本地内存在某一时刻将自身内容flush到主内存以保证数据可见性;
 * 这些特殊处理从我们程序员角度来看, 就是JMM制定的一系列规范, 我们在实际编码时, 并不用了解它们的实现细节,
 * JMM规定的这一系列规范是用来保证重排序不会影响多线程程序的正确性、也保证数据可见性等等多线程问题, 这一系列规范具化到我们实际编码时,
 * 就是这一个个并发编程的关键字和工具类, 即synchronized、volatile或者Lock等工具的原理其实就是JMM;
 * 而happens-before的那些具体规则的描述是JMM向程序员提供的对于它在底层做的这些工作的成果的精简描述,
 * 我们只要按照happens-before的那些规则来编写多线程程序, 就能够保证数据可见性, 这就是happens-before原则的存在意义;
 * 我们用happens-before的概念来阐述操作之间的内存可见性, 在JMM中, 如果一个操作执行的结果需要对另一个操作可见,
 * 那么这两个操作之间必须要存在happens-before关系; 两个操作之间具有happens-before关系,
 * 并不意味着前一个操作必须要在后一个操作之前执行! happens-before仅仅要求前一个操作(执行的结果)对后一个操作可见,
 * 且前一个操作按顺序排在第二个操作之前(the first is visible to and ordered before the second);
 * 这里详细解释一下什么叫做"两个操作之间具有happens-before关系, 并不意味着前一个操作必须要在后一个操作之前执行",
 * 例如上面的计算圆面积的例子, 由happens-before的程序次序规则(详见下方关于happens-before具体规则的描述), 我们可以得到:
 * 1). A happens-before B;
 * 2). B happens-before C;
 * 3). A happens-before C; (这一条规则是根据happens-before的传递性推导出来的)
 * 但是由上面的分析, 我们知道, 第一条happens-before程序运行规则(A happens-before B)其实并不一定被编译器或CPU遵守,
 * 即操作A可以在操作B之后执行, 也就是说, JMM并不要求操作A一定要在操作B之前执行; 因为, 操作A和操作B不存在数据依赖关系,
 * 操作A的执行结果不需要对操作B可见, 这也就不违背"happens-before仅仅要求前一个操作(执行的结果)对后一个操作可见",
 * 而且重排序操作A和操作B后(即先执行操作B再执行操作A)的执行结果, 与操作A和操作B按照happens-before顺序执行的结果一致,
 * 所以, JMM会认为这种重排序并不非法(not illegal);
 * 这就是对"两个操作之间具有happens-before关系, 并不意味着前一个操作必须要在后一个操作之前执行"这句话的解释;
 * 总的来说, happens-before原则是JMM为了方便程序员在阅读源码时或者编写多线程程序时理解内存可见性的概念而设计的, 对于程序员来说,
 * 我们并不关心两个操作的真正执行顺序为何(我们并不关心两个操作是否被重排序), 我们关心的是程序执行的语义不能被改变,
 * 即执行结果不能被改变; 因此, happens-before原则本质上和上面提到的as-if-serial语义是一回事儿,
 * 在可能有重排序的情况下, as-if-serial语义保证单线程内程序的执行结果不被改变,
 * happen-before原则保证正确同步的多线程程序的执行结果不被改变;
 *
 * happens-before规则有哪些:
 * 1. 程序次序规则(单线程规则)
 *    在一个单独的线程中, 按照程序代码的执行流顺序, (时间上)先执行的操作happens—before于(时间上)后执行的操作;
 *    即, 同一个线程中前面的所有写操作对后面的操作可见;
 * 2. 监视器锁规则(即synchronized关键字使用的Monitor锁的规则, 对Lock锁同样适用)
 *    一个unlock操作happens—before于后面(时间上的先后顺序)对同一个锁的lock操作;
 *    即, 当线程A在同步代码块内执行完成并释放了锁, 然后线程B进入相同同步代码块并获得了锁, 线程A解锁之前的写操作都对线程B可见;
 *    这其实就是为什么synchronized关键字和Lock具有数据可见性的原因;
 * 3. volatile变量规则
 *    对一个volatile变量的写操作happens—before于后面(时间上)对该变量的读操作;
 *    即, 当线程A写入(或者说修改)一个volatile变量, 在这之后, 线程B读取这个volatile变量, 那么, 线程A写入这个变量及其之前的写操作都对线程B可见;
 * 4. 线程启动规则
 *    调用thread.start()方法的线程前的每一个操作happens—before于thread.start()方法的执行;
 *    即, 假定线程A在执行过程中, 通过执行threadB.start()来启动线程B, 那么在执行启动线程B这条语句之前的所有操作都对线程B可见;
 *    注意：线程B启动之后, 线程A再对变量的修改对线程B未必可见;
 * 5. 线程终止规则
 *    线程的所有操作都happens—before于其他线程对此线程的终止检测;
 *    "对此线程的终止检测"是指, 在其他线程中通过thread.join()方法执行完成、thread.isAlive()的返回值等手段检测到线程已经终止执行;
 *    即, 线程A写入的所有变量, 在任意其它线程B调用A.join()并执行完成, 或者A.isAlive()返回false后, 都对B可见;
 * 6. 线程join规则
 *    线程的所有操作都happens-before于其他线程对此线程的join()检测;
 *    线程join规则是线程终止规则的一部分, 详见线程终止规则;
 * 7. 线程中断规则
 *    一个线程的所有操作happens-before于对该线程interrupt()的调用和该线程的中断检测以及中断事件的发生;
 *    即, 线程A写入的所有变量, 在线程B调用A.interrupt()然后线程A被中断后, 都对线程B可见;
 * 8. 对象终结规则(构造方法规则)
 *    一个对象的初始化完成(构造函数执行结束)happens—before于它的finalize()方法的开始;
 *    即, 对象调用finalize()方法时, 对象初始化完成的任意操作都会同步到主存;
 * 9. 传递性
 *    在同一个线程中, 如果"操作A"happens—before"操作B", "操作B"happens—before"操作C", 那么可以得出"操作A"happens—before"操作C";
 * 10. 并发工具类的happens-before原则, 即这些并发工具类都具有happens-before原则:
 *    1). 线程安全的容器的get()一定能看到在此之前的put()等存入动作
 *    2). CountDownLatch
 *    3). Semaphore
 *    4). Future
 *    5). 线程池
 *    6). CyclicBarrier
 */

public class HappensBefore {
    public static void main(String[] args) {
    }
}
