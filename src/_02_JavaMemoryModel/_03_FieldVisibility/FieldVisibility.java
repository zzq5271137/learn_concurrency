package _02_JavaMemoryModel._03_FieldVisibility;

/*
 * 参考: https://www.jianshu.com/p/e0e80d004a86
 *      https://www.jianshu.com/p/8a58d8335270
 *
 * 此处演示可见性(Field Visibility)带来的问题;
 *
 * 首先明确一点, 在计算机内存中是有缓存的, 对应到JMM中, 就是主内存(Shared Cache, Main Memory)和本地内存(Local Cache, Working Memory);
 * 即, 每一个线程在运行时都有一个本地内存, 本地内存与本地内存之间是不能直接通信的, 必须通过主内存进行通信,
 * 当线程运行时, 线程需要从主内存中读取数据读到本地内存(或者叫工作内存)中从而去做进一步操作(准确来说是先从工作内存读取数据,
 * 如果工作内存中没有该数据, 工作内存会从主内存中读取, 线程只能操作自己工作内存中的变量, 详见下方关于对JMM的描述),
 * 而线程对数据的修改也仅仅是对工作内存中数据的修改, 只有工作地内存中的数据同步到主内存中, 线程做的这些修改才能对其他线程可见;
 * 所以, 当一个线程对某一数据做了修改但是还没有同步到主内存时, 其他线程从主内存中读到的这个数据还是旧的数据, 就造成了数据可见性问题;
 *
 * 在硬件层面, 程序是由CPU中的核(Core)调度执行的, 一个线程就运行在一个Core中, 运行时的所有数据都是存储在主内存(RAM)中的,
 * 而Core和RAM之间还隔了好几层缓存, 之所以加入这一层一层的缓存层, 是因为CPU的处理速度是非常快的,
 * 如果让CPU每次都直接从RAM读取数据, 会极大得降低CPU运行效率;
 * 从Core到RAM的结构为:
 * 核(Core) -> 寄存器(Register) -> 一级缓存(L1 Cache) -> 二级缓存(L2 Cache) -> 三级缓存(L3 Cache) -> 主内存(RAM);
 * 从寄存器到主内存(这些都是存储结构), 他们的容量是逐渐增大的(RAM最大), 而Core从他们那里读取数据的速度是逐渐变小的(寄存器最快);
 * "缓存"的作用正如字面解释, 是用来存储临时数据的, Core会优先从寄存器读取数据, 如果没有, 就从一级缓存中找, 以此类推;
 * 每个Core都有自己独占的寄存器和一级缓存, 而二级缓存是多个Core共享一个, 三级缓存和RAM是全局共享, 这其实就产生了数据可见性问题,
 * 因为Core对数据的修改不是直接修改RAM里的数据(即不是直接修改全局共享的存储区域中的数据),
 * Core会先修改自己的独占缓存中的数据(比如Core从一级缓存中读取一个数据, 然后对这个数据的修改也是修改的一级缓存中的数据),
 * 然后, 数据会从Core自己的独占缓存中同步回共享存储区(即从一级缓存同步回二级缓存, 依次向下, 直到同步回RAM);
 * 当一个Core修改了一个一级缓存中的数据, 但是没有同步回共享区域时, 其他Core从主内存中读的数据就是过期的, 就造成了数据可见性问题;
 * 以上是底层硬件层面的描述, 而对于软件或者说线程层面来说就是, 线程是运行在Core中的, 一个线程就对应一个Core,
 * Java作为高级语言, 屏蔽了CPU多层缓存这些底层细节, 用JMM定义了一套读写内存数据的规范, 虽然我们不再需要关心多层缓存的问题,
 * 但是, JMM抽象出了主内存和本地内存的概念, 这里说的本地内存并不是真的是一块给每个线程分配的内存, 而是JMM的一个抽象, 如果真要说,
 * 那么本地内存对应到硬件底层结构, 就是寄存器和一级缓存(或者可能也包含了二级缓存, 这跟不同的CPU的设计相关, 总之就是Core独占的缓存区);
 * 多线程程序就是有多个Core同时在运行(当然同一时刻只有一个Core在运行, 多线程的实现由CPU运行时间片的分配进行调度的),
 * 所以, 由于每个线程自己独占的本地内存与主内存之间没有及时同步, 就造成了数据可见性问题;
 *
 * 这其实就解释了为什么我们需要JMM, 因为如果没有JMM标准, 多线程程序的执行结果很大程度上是依赖于处理器(Core)的,
 * 即, 如果有的处理器的缓存层比较少, 或者会比较频繁地做同步, 或者同步的效率高, 那么产生可见性问题的概率就比较小,
 * 但有的处理器的情况可能相反, 那么产生可见性问题的概率就高, 所以不同的处理器会产生不同的运行结果, 这样是无法保证线程安全的;
 * 所以, 我们一定要有一个规则或者标准, 来让不同的CPU知道什么时候一定要做同步, 这就是JMM;
 * 当然, 这只是JMM对于可见性问题这一方面的作用, JMM还包括了很多其他的规范, 例如重排序、原子性等,
 * JMM也是synchronized、volatile、Lock等的原理;
 *
 * JMM中关于主内存和本地内存的关系的具体规定为:
 * 1. 所有的变量都存储在主内存中, 同时每个线程也有自己独立的工作内存, 工作内存中的变量内容是主内存中的拷贝;
 * 2. 线程不能直接读写主内存中的变量, 而是只能操作自己工作内存中的变量, 然后再同步到主内存中;
 * 3. 主内存是所有线程共享的, 但线程间不共享工作内存, 如果线程间需要通信, 必须借助主内存中转来完成;
 * 简而言之, 所有的共享变量存在于主内存中, 每个线程有自己的本地内存, 而且线程读写共享数据也是通过本地内存交换的;
 *
 * 下面的代码例子, 乍一看会打印3种结果:
 * 1. b = 2, a = 1
 *    即线程2先执行完成(即直接打印出b和a), 由于b和a还没有经过线程1的修改, 所以打印出的是初始值;
 * 2. b = 3, a = 3
 *    即线程1先执行完成(即修改了b和a的值), 线程2再执行(打印), 所以此时打印出的值是修改过后的b和a的值;
 * 3. b = 2, a = 3
 *    即线程1执行了一半(即修改了a的值但是还没有修改b的值), 线程2就执行了, 所以打印出的值是修改后的a的值和未修改的b的值;
 * 但实际上, 由于可见性带来的问题, 还有第4种结果, 即b = 3, a = 1;
 * 这是由于, 当线程1先执行完成(即b和a都被修改了), 但是当线程2执行时, 由于线程1修改的a的值还没有同步到主内存,
 * 所以线程2看到的是修改后的b的值和未修改的a的值, 换句话说, 就是线程1对b的修改对线程2可见, 而线程1对a的修改对线程2不可见;
 * 由于线程修改的数据未能及时同步到主内存从而使其他线程使用过期的数据进行操作而带来的错误, 就是可见性带来的问题;
 *
 * 而如果把a和b都声明成volatile, 就不会出现上面的第4种结果;
 * 因为, volatile的性质是, 线程对一个volatile变量的读, 总是能看到(任意线程)对这个volatile变量最后的写入;
 * 原理是, 当一个变量被声明为是volatile, 那么当线程在本地内存对它做修改之后, 就会立马强制把修改后的值刷回(flush)到主内存,
 * 这样的话, 其他线程从主内存中读到的值始终都是最新的;
 */

import java.util.concurrent.TimeUnit;

public class FieldVisibility {
    // int a = 1;
    // int b = 2;
    volatile int a = 1;
    volatile int b = 2;

    public void change() {
        a = 3;
        b = a;
    }

    public void print() {
        System.out.println("b = " + b + ", a = " + a);
    }

    public static void main(String[] args) throws InterruptedException {
        while (true) {
            FieldVisibility instance = new FieldVisibility();
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        TimeUnit.MILLISECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    instance.change();
                }
            }, "One").start();
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        TimeUnit.MILLISECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    instance.print();
                }
            }, "Two").start();
        }
    }
}
