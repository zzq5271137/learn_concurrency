package _02_JavaMemoryModel._01_Introduction;

/*
 * 从Java代码到CPU指令的变化过程以及为什么需要JMM:
 * 我们在Java代码中, 使用的控制并发的手段, 例如synchronized关键字、Lock等, 最终都是要转化成CPU指令来生效的,
 * 从Java代码转化到最终执行的CPU指令的流程为:
 * 1. 最开始, 我们编写的Java代码, 是*.java文件;
 * 2. 在执行完编译(javac命令)后, 从刚才的*.java文件会产生一个新的Java字节码文件(*.class文件);
 * 3. JVM会执行刚才产生的字节码文件(*.class文件), 并把字节码文件转化为机器指令;
 * 4. 机器指令可以直接在CPU上运行, 也就是最终的程序执行;
 * 而不同的JVM实现会带来不同的"翻译", 不同的CPU平台的机器指令又千差万别; 所以, 我们在Java代码层写的各种Lock,
 * 其实最后依赖的是JVM的具体实现(不同版本会有不同)和CPU的指令, 才能帮我们达到线程安全的效果;
 * 由于最终效果依赖处理器, 不同处理器结果不一样, 这样无法保证并发安全, 所以需要一个标准,
 * 让多线程运行的结果可预期, 这个标准就是Java Memory Model(即JMM);
 *
 * JVM内存结构 VS Java内存模型 VS Java对象模型:
 * 1. JVM内存结构
 *    参考: https://blog.csdn.net/rongtaoup/article/details/89142396
 *         https://www.cnblogs.com/hqji/p/6582365.html
 *    JVM内存结构, 和Java虚拟机的运行时区域有关;
 *    首先, Java代码是运行在虚拟机上的, 虚拟机会把程序运行时的内存分为不同的区域(5个), 每个区域有不同的作用;
 *    当字节码文件(*.class文件)经过类加载器(Class Loader)的加载之后, 就会在运行时数据区(Runtime Data Area)中产生5个不同的区域,
 *    这5个区域为:
 *    1). 方法区(Method Area)
 *        方法区包含所有的已被虚拟机加载的类信息、即时编译器编译后的代码缓存、static静态变量以及常量信息;
 *        所谓的加载的类信息、静态变量、常量等, 实际上是JVM为每个类创建的instanceKlass对象, 详见下面Java对象模型的描述;
 *        运行时常量池(Runtime Constant Pool)是方法区的一部分, class文件中除了有类的版本、字段、方法、接口等描述信息外,
 *        还有一项信息是常量池表(Constant Pool Table), 用于存放编译期生成的各种字面量和符号引用,
 *        这部分内容将在类加载后存放到方法区的运行时常量池中;
 *    2). 堆(Heap)
 *        堆是整个运行时数据区最大的一块区域(占用的内存最多), 它用来存储实例对象(通过new创建的东西都在这里, 包括数组);
 *        整个JVM运行时只有一个堆区, 被所有线程共享;
 *        堆的优势是可以动态的分配内存大小, 生存期也不必事先告诉编译器, Java的垃圾收集器会自动收取这些不再使用的对象,
 *        但缺点是, 由于要在运行时动态分配内存, 存取速度慢;
 *    3). Java栈(Java Stack)或者叫虚拟机栈(VM Stack)
 *        栈中存储的是各个方法的栈帧, 栈帧中存储的是Java的基本数据类型的变量(包括对堆中对象的引用, 即地址);
 *        每个栈中的数据(基本数据类型和对象引用)都是私有的, 其他栈不能访问;
 *        栈分为3部分, 即基本类型变量区、执行环境上下文、操作指令区(存放操作指令);
 *        栈的优势是, 存取速度比堆要快, 仅次于直接位于CPU的寄存器,
 *        但缺点是, 存在stack中的数据大小与生存期必须事先确定, 缺乏灵活性;
 *    4). 本地方法栈(Native Method Stack)
 *        本地方法栈与虚拟机栈的作用非常类似, 其区别只是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,
 *        而本地方法栈则是为虚拟机使用到的本地(Native)方法服务;
 *        同虚拟机栈一样, 本地方法栈是线程私有的;
 *    5). 程序计数器(Program Counter Register)
 *        程序计数器是当前线程所执行的字节码的行号指示器;
 *        程序计数器也是线程私有的;
 *    总结, 方法区和堆是在运行时所有线程共享的区域, 而剩下3个区域是每个线程私有的区域;
 * 2. Java内存模型
 *    参考: https://www.jianshu.com/p/e0e80d004a86
 *         https://www.jianshu.com/p/8a58d8335270
 *    Java内存模型, 和Java的并发编程有关;
 * 3. Java对象模型
 *    参考: https://blog.csdn.net/w372426096/article/details/81167669
 *    Java对象模型, 和Java对象在虚拟机中的表现形式有关;
 *    由于Java是面向对象的, 所以每一个对象在JVM中存储是有一定结构的, 这个结构就是Java对象模型;
 *    首先, 一个Java对象可以分为三个部分存储在内存中, 分别是对象头(Header)、实例数据(Instance Data)和对齐填充(Padding);
 *    在Java中, JVM中的对象模型包含两部分: Oop和Klass, 在类被加载的时候, JVM会给类创建一个instanceKlass对象,
 *    其中包含了类信息、常量、静态变量、即时编译器编译后的代码等, 存储在方法区, 用来在JVM层表示该Java类;
 *    而在代码中使用new创建一个实例对象后, JVM就会创建一个instanceOopDesc对象, 该对象包含对象头和实例数据,
 *    对象头中保存的是锁的状态标志等信息, 还包含元数据指针, 指向其对应类的instanceKlass对象(instanceKlass对象存在方法区中),
 *    而实例数据则是一个实例对象的有效信息, 即Java代码中定义的各种类型的字段内容;
 *    即, 对象头是一个实例对象的额外开销, 实例数据才是对象的有效信息;
 *    而当我们new出来一个对象并赋值给一个变量时, 这个变量其实是对上面instanceOopDesc的引用, 这个变量是存储在虚拟机栈中的;
 *    总的来说就是, 对象的元数据(instanceKlass)保存在方法区, 对象的实例(instanceOopDesc)保存在Java堆,
 *    对象的引用保存在虚拟机栈中, 这就是Java对象模型;
 */

public class Introduction {
    public static void main(String[] args) {
    }
}
