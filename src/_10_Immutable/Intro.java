package _10_Immutable;

/*
 * 什么是不变性(Immutable):
 * 如果对象在被创建后, 状态就不能被改变, 那么它就具有不变性(即不可变对象);
 * 比如, 一个Person对象, person, 它的age(int类型)和name(String类型)都不能再变, 那么person就是个不可变对象;
 * 详见ImmutableDemo.java
 *
 * 不变性与线程安全:
 * 具有不变性的对象一定是线程安全的(好像是废话?), 我们不需要对其采取任何额外的安全措施, 也能保证线程安全;
 * "不可变"是并发安全版图中一个重要的模块, 也是一个很重要的策略;
 *
 * 不变性与final关键字的关系:
 * 简单地用final修饰并不意味着具有不变性; 对于基本数据类型的变量而言, 被final修饰后确实就具有不变性了;
 * 但是对于引用数据类型的变量而言, 只有该对象能够保证自身被创建之后, 状态永远不会变, 才具有不变性,
 * 因为使用final修饰一个引用类型的变量, 只是说这个变量的指向是不可变的, 不代表它指向的对象本身的属性是不可变的;
 * 那么我们如何利用final去实现对象的不可变呢? 是把所有属性都声明为final吗? 这样是不够的,
 * 因为如果某一个属性也是引用类型的, 那么使用final修饰这个属性也不能保证这个属性的属性不会变;
 * 那么该怎么做呢? 其实很简单, 就是首先把这些引用类型的属性声明为final, 然后不提供修改这些属性的方法给外界;
 * 因为, 不可变/不变性只是个概念, 只要满足一个变量无法被修改(包括对象的状态无法被修改), 那它就具有不变性;
 * 所以, 我们总结出, 满足以下条件时, 对象才是不可变的:
 * 1. 对象在被创建后, 其状态就不能被修改;
 * 2. 所有属性都是final修饰的;
 * 3. 对象在创建/初始化过程中, 没有发生逸出(逸出在之前的线程八大核心中有讲过);
 * 其实, 第一个条件是对象具有不可变性的表现特征, 而不是条件; 第二个条件是希望对象具有不可变性的一种举措,
 * 当然这种举措不一定使得对象具有不可变性, 还需要引用类型属性指向的对象具备不可变性;
 * 而且这种举措可有可无(如所有属性都是private且不向外提供修改其属性的方法, 且保证初始化时不逸出, 那么它自然而然就具有不变性);
 * 简而言之, "对象创建后, 其状态就不能修改"是"对象具备不可变性"的充分必要条件;
 * "所有属性都是final修饰"不是"对象具备不可变性"的必要条件;
 * 详见ImmutableObjectDemo.java
 *
 * 栈封闭:
 * 栈封闭, 即把变量写在线程内部, 即在方法内新建变量; 在方法内新建的局部变量, 实际上是存储在每个线程私有的栈中的(详见JVM内存结构),
 * 每个线程的栈是不能被其他线程访问到的, 所以不会有线程安全问题; 这就是著名的"栈封闭"技术,
 * 是"线程封闭"技术的一种情况;
 * 详见StackConfinement.java
 */

public class Intro {
    public static void main(String[] args) {
    }
}
