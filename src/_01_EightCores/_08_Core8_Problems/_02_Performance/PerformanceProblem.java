package _01_EightCores._08_Core8_Problems._02_Performance;

/*
 * 多线程带来的问题主要有两大部分, 第一部分是线程安全问题, 第二部分是性能问题, 这里介绍性能问题;
 *
 * 为什么多线程会带来性能问题, 主要的开销有以下几点:
 * 1. 调度: 上下文切换
 *    a). 什么是上下文和上下文切换:
 *        上下文切换可以认为是内核(操作系统的核心)在CPU上对于进程(包括线程)进行的以下活动:
 *        (1). 挂起一个进程, 将这个进程在CPU中的状态(即上下文)存储于内存中的某处;
 *        (2). 在内存中检索下一个进程的上下文并将其在CPU的寄存器中恢复;
 *        (3). 跳转到该进程的程序计数器所指向的位置(即跳转到进程被中断时的代码行), 以恢复该进程;
 *        上下文切换又叫环境切换, 在操作系统中, CPU切换到另一个线程需要保存当前线程的状态并恢复另一个线程的状态,
 *        即, 当前运行任务转为就绪(或者挂起)状态, 另一个被选定的就绪任务成为当前任务,
 *        上下文切换包括保存当前任务的运行环境, 恢复将要运行任务的运行环境,
 *        这里所谓的运行环境就是上下文, 上下文主要是和寄存器与程序计数器相关的, 上下文是保存在内存中的;
 *        上下文切换的开销是非常大的, 有时候甚至比线程执行的时间更长, 通常一次上下文切换,
 *        会消耗5000~10000个CPU的时钟周期, 大约是几微秒;
 *    b). 缓存开销-缓存失效:
 *        对于CPU而言, 我们要考虑到缓存失效的问题, 因为一旦进行了上下文切换, CPU即将执行不同线程的不同代码,
 *        原来的缓存就没有什么价值了, 所以CPU就需要重新进行缓存, 这导致线程在被调度之后一开始的启动速度有点慢,
 *        因为它之前的缓存大部分都失效了, 所以上下文切换会带来很大的缓存开销;
 *        所以CPU为了防止过于频繁的上下文切换而带来过大的缓存开销, 通常会设置一个最小执行时间,
 *        即两次上下文切换之间不能小于这个最小阈值;
 *    c). 何时会导致密集的上下文切换:
 *        比如程序经常频繁的锁竞争, 或者经常去IO读写, 或者其他原因导致频繁的线程阻塞, 这些时候会带来频繁的上下文切换;
 * 2. 协作: 内存同步
 *    JMM模型规定程序有一个主内存和各个线程自己的缓存(即本地内存), 使用缓存可以大大提高程序执行的速度, 因为不用每次去和主存进行同步;
 *    但是, 在多线程中我们经常使用的synchronized、volatile等关键字会让不同线程的自己的缓存失效(因为他们拥有的保持数据可见性的特性),
 *    所以使用他们会让内存同步成为一个不小的开销;
 */

public class PerformanceProblem {
    public static void main(String[] args) {
    }
}
