package _03_DeadLock._01_Introduction;

/*
 * 什么是死锁:
 * 1. 死锁一定发生在并发中;
 * 2. 互不相让:
 *    当两个(或更多)线程(或进程)相互持有对方所需要的资源, 又不主动释放, 导致所有人都无法继续前进,
 *    导致程序陷入无尽的阻塞, 这就是死锁;
 * 如果多个线程之间的依赖关系是环形, 存在环路的锁的依赖关系, 那么就有可能发生死锁;
 * 例如, 当线程A持有锁1, 而它此时正试图获得锁2; 同时线程B持有锁2, 而它此时正试图获得锁3;
 * 同时线程C持有锁3, 而它此时正试图获得锁1; 这时, 线程A、B和C就进入了死锁状态;
 *
 * 死锁的影响:
 * 死锁的影响在不同系统中是不一样的, 这取决于系统对死锁的处理能力, 比如:
 * 1). 在数据库中: 一部分数据库拥有检测死锁并放弃事务的能力;
 * 2). JVM中: JVM有一些工具可以帮助我们检测死锁, 但是它不具备自动处理死锁的能力;
 * 对于JVM而言, 死锁发生几率不高, 但是危害巨大, 例如整个系统崩溃、子系统崩溃、性能降低等等;
 * 还有一点值得注意, 压力测试无法找出所有潜在的死锁;
 */

public class Introduction {
    public static void main(String[] args) {
    }
}
