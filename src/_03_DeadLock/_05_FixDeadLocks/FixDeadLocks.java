package _03_DeadLock._05_FixDeadLocks;

/*
 * 修复死锁的策略:
 * 1. 避免策略
 *    如, 哲学家就餐的换手方案、转账换序方案;
 *    避免策略的思路是, 要在代码中避免以相反的顺序获取锁的情况;
 *    代码示例详见FixTransferMoney.java
 * 2. 检测与恢复策略
 *    在程序中, 隔一段时间就检测是否有死锁, 如果有, 就剥夺某一个资源来打开死锁;
 *    在实际开发中, 死锁的检测需要检测算法, 即使用锁的调用链路图; 在检测与恢复策略中允许死锁的发生,
 *    但是我们需要在每次调用锁时都记录下来(使用有向图), 即"锁的调用链路图",
 *    然后定期检查"锁的调用链路图"中是否存在环路, 一旦检测到环路, 即检测到发生了死锁,
 *    我们就用死锁恢复机制进行恢复; 恢复方法可以有2个:
 *    a). 进程/线程终止
 *        逐个地终止线程, 直到死锁消除; 终止线程的顺序需要仔细考虑, 如:
 *        1). 根据优先级(比如前台交互的线程的优先级高一些, 所以可以先不终止, 而后台交互的线程的优先级低一些,
 *            终止他们不会造成太大影响, 那就优先终止他们);
 *        2). 根据已占用资源和还需要的资源(比如一个线程已经占用很多资源而且快要完成了, 那就先不终止它);
 *        3). 根据已经运行的时间(比如一个线程已经运行很久而且快要完成了, 那就先不终止它);
 *    b). 资源抢占
 *        把已经分发出去的给收回来; 让线程回退几步, 而不是去结束整个线程, 这样成本比较低;
 *        缺点: 可能某一个线程会一直被抢占, 造成饥饿;
 * 3. 鸵鸟策略
 *    鸵鸟这种动物在遇到危险的时候, 通常就会把头埋在地里, 这样一来它就看不到危险了;
 *    而鸵鸟策略的意思就是说, 如果我们发生死锁的概率极其低, 那么我们直接就忽略它, 直到死锁发生的时候再人工修复;
 *
 * 在实际工程中如何有效避免死锁:
 * 1. 设置超时时间
 *    synchronized是不具备尝试锁的能力的, 推荐使用Lock的tryLock()方法;
 *    示例详见TryLockDemo.java
 * 2. 多实用并发类, 而不是自己设计锁
 *    如ConcurrentHashMap, ConcurrentLinkedQueue, java.util.concurrent.atomic包中的工具等等;
 *    多用并发集合, 少用同步集合(Collections.synchronizedMap、Collections.synchronizedList等),
 *    并发集合比同步集合的可扩展性更好;
 * 3. 尽量降低锁的使用粒度: 用不同的锁而不是同一个锁(不要一整个类的所有功能就用一把锁)
 * 4. 在使用synchronized时, 如果能使用同步代码块, 就不要使用同步方法, 自己去指定锁对象
 * 5. 给线程起个有意义的名字, debug和排查时事半功倍, 框架和JDK都遵守这个实践
 * 6. 尽量避免使用锁的嵌套
 * 7. 分配资源前先看看能不能收回来
 * 8. 尽量不要几个功能共用同一把锁, 专锁专用
 */

public class FixDeadLocks {
    public static void main(String[] args) {
    }
}
