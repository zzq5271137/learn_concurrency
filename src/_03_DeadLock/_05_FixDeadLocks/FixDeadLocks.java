package _03_DeadLock._05_FixDeadLocks;

/*
 * 修复死锁的策略:
 * 1. 避免策略
 *    如, 哲学家就餐的换手方案、转账换序方案;
 *    避免策略的思路是, 要在代码中避免以相反的顺序获取锁的情况;
 *    代码示例详见FixTransferMoney.java
 * 2. 检测与恢复策略
 *    在程序中, 隔一段时间就检测是否有死锁, 如果有, 就剥夺某一个资源来打开死锁;
 *    在实际开发中, 死锁的检测需要检测算法, 即使用锁的调用链路图; 在检测与恢复策略中允许死锁的发生,
 *    但是我们需要在每次调用锁时都记录下来(使用有向图), 即"锁的调用链路图",
 *    然后定期检查"锁的调用链路图"中是否存在环路, 一旦检测到环路, 即检测到发生了死锁,
 *    我们就用死锁恢复机制进行恢复; 恢复方法可以有2个:
 *    a). 进程/线程终止
 *        逐个地终止线程, 直到死锁消除; 终止线程的顺序需要仔细考虑, 如:
 *        1). 根据优先级(比如前台交互的线程的优先级高一些, 所以可以先不终止, 而后台交互的线程的优先级低一些,
 *            终止他们不会造成太大影响, 那就优先终止他们);
 *        2). 根据已占用资源和还需要的资源(比如一个线程已经占用很多资源而且快要完成了, 那就先不终止它);
 *        3). 根据已经运行的时间(比如一个线程已经运行很久而且快要完成了, 那就先不终止它);
 *    b). 资源抢占
 *        把已经分发出去的给收回来; 让线程回退几步, 而不是去结束整个线程, 这样成本比较低;
 *        缺点: 可能某一个线程会一直被抢占, 造成饥饿;
 * 3. 鸵鸟策略
 *    鸵鸟这种动物在遇到危险的时候, 通常就会把头埋在地里, 这样一来它就看不到危险了;
 *    而鸵鸟策略的意思就是说, 如果我们发生死锁的概率极其低, 那么我们直接就忽略它, 直到死锁发生的时候再人工修复;
 */

public class FixDeadLocks {
    public static void main(String[] args) {
    }
}
